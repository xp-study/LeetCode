# 如何在10亿数中找出前1000大的数

![寻找前1000大的数](http://gitlab.wsh-study.com/xp-study/LeeteCode/blob/master/TopK问题/images/寻找前1000大的数/寻找前1000大的数1.jpg)

![寻找前1000大的数](http://gitlab.wsh-study.com/xp-study/LeeteCode/blob/master/TopK问题/images/寻找前1000大的数/寻找前1000大的数2.jpg)

![寻找前1000大的数](http://gitlab.wsh-study.com/xp-study/LeeteCode/blob/master/TopK问题/images/寻找前1000大的数/寻找前1000大的数3.jpg)

![寻找前1000大的数](http://gitlab.wsh-study.com/xp-study/LeeteCode/blob/master/TopK问题/images/寻找前1000大的数/寻找前1000大的数4.jpg)

![寻找前1000大的数](http://gitlab.wsh-study.com/xp-study/LeeteCode/blob/master/TopK问题/images/寻找前1000大的数/寻找前1000大的数5.jpg)

![寻找前1000大的数](http://gitlab.wsh-study.com/xp-study/LeeteCode/blob/master/TopK问题/images/寻找前1000大的数/寻找前1000大的数6.jpg)

![寻找前1000大的数](http://gitlab.wsh-study.com/xp-study/LeeteCode/blob/master/TopK问题/images/寻找前1000大的数/寻找前1000大的数7.jpg)

![寻找前1000大的数](http://gitlab.wsh-study.com/xp-study/LeeteCode/blob/master/TopK问题/images/寻找前1000大的数/寻找前1000大的数8.jpg)

小史：我可以用分治法，这有点类似快排中partition的操作。随机选一个数t，然后对整个数组进行partition，会得到两部分，前一部分的数都大于t，后一部分的数都小于t。

![寻找前1000大的数](http://gitlab.wsh-study.com/xp-study/LeeteCode/blob/master/TopK问题/images/寻找前1000大的数/寻找前1000大的数9.jpg)

![寻找前1000大的数](http://gitlab.wsh-study.com/xp-study/LeeteCode/blob/master/TopK问题/images/寻找前1000大的数/寻找前1000大的数10.jpg)

小史：如果说前一部分总数大于1000个，那就继续在前一部分进行partition寻找。如果前一部分的数小于1000个，那就在后一部分再进行partition，寻找剩下的数。

![寻找前1000大的数](http://gitlab.wsh-study.com/xp-study/LeeteCode/blob/master/TopK问题/images/寻找前1000大的数/寻找前1000大的数11.jpg)

![寻找前1000大的数](http://gitlab.wsh-study.com/xp-study/LeeteCode/blob/master/TopK问题/images/寻找前1000大的数/寻找前1000大的数12.jpg)

![寻找前1000大的数](http://gitlab.wsh-study.com/xp-study/LeeteCode/blob/master/TopK问题/images/寻找前1000大的数/寻找前1000大的数13.jpg)

![寻找前1000大的数](http://gitlab.wsh-study.com/xp-study/LeeteCode/blob/master/TopK问题/images/寻找前1000大的数/寻找前1000大的数14.jpg)

![寻找前1000大的数](http://gitlab.wsh-study.com/xp-study/LeeteCode/blob/master/TopK问题/images/寻找前1000大的数/寻找前1000大的数15.jpg)

小史：首先，partition的过程，时间是o(n)。我们在进行第一次partition的时候需要花费n，第二次partition的时候，数据量减半了，所以只要花费n/2，同理第三次的时候只要花费n/4，以此类推。而n+n/2+n/4+...显然是小于2n的，所以这个方法的渐进时间只有o(n)

附等比数列求和公式

![寻找前1000大的数](http://gitlab.wsh-study.com/xp-study/LeeteCode/blob/master/TopK问题/images/寻找前1000大的数/寻找前1000大的数16.jpg)

![寻找前1000大的数](http://gitlab.wsh-study.com/xp-study/LeeteCode/blob/master/TopK问题/images/寻找前1000大的数/寻找前1000大的数17.jpg)

（注：这里的时间复杂度计算只是简化计算版，真正严谨的数学证明可以参考算法导论相关分析）

![寻找前1000大的数](http://gitlab.wsh-study.com/xp-study/LeeteCode/blob/master/TopK问题/images/寻找前1000大的数/寻找前1000大的数18.jpg)

![寻找前1000大的数](http://gitlab.wsh-study.com/xp-study/LeeteCode/blob/master/TopK问题/images/寻找前1000大的数/寻找前1000大的数19.jpg)

![寻找前1000大的数](http://gitlab.wsh-study.com/xp-study/LeeteCode/blob/master/TopK问题/images/寻找前1000大的数/寻找前1000大的数20.jpg)

半分钟过去了。

![寻找前1000大的数](http://gitlab.wsh-study.com/xp-study/LeeteCode/blob/master/TopK问题/images/寻找前1000大的数/寻找前1000大的数21.jpg)

![寻找前1000大的数](http://gitlab.wsh-study.com/xp-study/LeeteCode/blob/master/TopK问题/images/寻找前1000大的数/寻找前1000大的数22.jpg)

![寻找前1000大的数](http://gitlab.wsh-study.com/xp-study/LeeteCode/blob/master/TopK问题/images/寻找前1000大的数/寻找前1000大的数23.jpg)

![寻找前1000大的数](http://gitlab.wsh-study.com/xp-study/LeeteCode/blob/master/TopK问题/images/寻找前1000大的数/寻找前1000大的数24.jpg)

![寻找前1000大的数](http://gitlab.wsh-study.com/xp-study/LeeteCode/blob/master/TopK问题/images/寻找前1000大的数/寻找前1000大的数25.jpg)

![寻找前1000大的数](http://gitlab.wsh-study.com/xp-study/LeeteCode/blob/master/TopK问题/images/寻找前1000大的数/寻找前1000大的数26.jpg)

![寻找前1000大的数](http://gitlab.wsh-study.com/xp-study/LeeteCode/blob/master/TopK问题/images/寻找前1000大的数/寻找前1000大的数27.jpg)

小史一时慌了神。

![寻找前1000大的数](http://gitlab.wsh-study.com/xp-study/LeeteCode/blob/master/TopK问题/images/寻找前1000大的数/寻找前1000大的数28.jpg)

他回忆起了之前吕老师给他讲解[bitmap](http://mp.weixin.qq.com/s?__biz=MzIzMTE1ODkyNQ==&mid=2649409856&idx=1&sn=448772acaf9b2f1a87f4d7c1caf4caa9&chksm=f0b60ca2c7c185b4cb93d0deffed461e6ba3e421e362c17102415e351a496792fa26e0282dc0&scene=21#wechat_redirect)时的一些细节。突然有了一个想法。

![寻找前1000大的数](http://gitlab.wsh-study.com/xp-study/LeeteCode/blob/master/TopK问题/images/寻找前1000大的数/寻找前1000大的数29.jpg)

![寻找前1000大的数](http://gitlab.wsh-study.com/xp-study/LeeteCode/blob/master/TopK问题/images/寻找前1000大的数/寻找前1000大的数30.jpg)

![寻找前1000大的数](http://gitlab.wsh-study.com/xp-study/LeeteCode/blob/master/TopK问题/images/寻找前1000大的数/寻找前1000大的数31.jpg)

![寻找前1000大的数](http://gitlab.wsh-study.com/xp-study/LeeteCode/blob/master/TopK问题/images/寻找前1000大的数/寻找前1000大的数32.jpg)

小史在纸上画了画。

![寻找前1000大的数](http://gitlab.wsh-study.com/xp-study/LeeteCode/blob/master/TopK问题/images/寻找前1000大的数/寻找前1000大的数33.jpg)

![寻找前1000大的数](http://gitlab.wsh-study.com/xp-study/LeeteCode/blob/master/TopK问题/images/寻找前1000大的数/寻找前1000大的数34.jpg)

![寻找前1000大的数](http://gitlab.wsh-study.com/xp-study/LeeteCode/blob/master/TopK问题/images/寻找前1000大的数/寻找前1000大的数35.jpg)

![寻找前1000大的数](http://gitlab.wsh-study.com/xp-study/LeeteCode/blob/master/TopK问题/images/寻找前1000大的数/寻找前1000大的数36.jpg)

![寻找前1000大的数](http://gitlab.wsh-study.com/xp-study/LeeteCode/blob/master/TopK问题/images/寻找前1000大的数/寻找前1000大的数37.jpg)

![寻找前1000大的数](http://gitlab.wsh-study.com/xp-study/LeeteCode/blob/master/TopK问题/images/寻找前1000大的数/寻找前1000大的数38.jpg)

![寻找前1000大的数](http://gitlab.wsh-study.com/xp-study/LeeteCode/blob/master/TopK问题/images/寻找前1000大的数/寻找前1000大的数39.jpg)

![寻找前1000大的数](http://gitlab.wsh-study.com/xp-study/LeeteCode/blob/master/TopK问题/images/寻找前1000大的数/寻找前1000大的数40.jpg)

![寻找前1000大的数](http://gitlab.wsh-study.com/xp-study/LeeteCode/blob/master/TopK问题/images/寻找前1000大的数/寻找前1000大的数41.jpg)

![寻找前1000大的数](http://gitlab.wsh-study.com/xp-study/LeeteCode/blob/master/TopK问题/images/寻找前1000大的数/寻找前1000大的数42.jpg)

![寻找前1000大的数](http://gitlab.wsh-study.com/xp-study/LeeteCode/blob/master/TopK问题/images/寻找前1000大的数/寻找前1000大的数43.jpg)

![寻找前1000大的数](http://gitlab.wsh-study.com/xp-study/LeeteCode/blob/master/TopK问题/images/寻找前1000大的数/寻找前1000大的数44.jpg)

![寻找前1000大的数](http://gitlab.wsh-study.com/xp-study/LeeteCode/blob/master/TopK问题/images/寻找前1000大的数/寻找前1000大的数45.jpg)

理解了算法之后，小史的代码写起来也是非常快，不一会儿就写好了：

```java
  public static int findKthLargest(int[] nums, int k) {
        PriorityQueue<Integer> pq = new PriorityQueue<>(k, new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return o2 - o1;
            }
        });

        for (int val : nums) {
            pq.add(val);
            // 维护堆的大小为 K
            if (pq.size() > k) {
                pq.poll();
            }
        }
        return pq.peek();
    }
```

