#### 1986. 完成任务的最少工作时间段

你被安排了 n 个任务。任务需要花费的时间用长度为 n 的整数数组 tasks 表示，第 i 个任务需要花费 tasks[i] 小时完成。一个 工作时间段 中，你可以 至多 连续工作 sessionTime 个小时，然后休息一会儿。

你需要按照如下条件完成给定任务：

* 如果你在某一个时间段开始一个任务，你需要在 **同一个** 时间段完成它。

* 完成一个任务后，你可以 **立马** 开始一个新的任务。

* 你可以按 **任意顺序** 完成任务。

给你 `tasks` 和 `sessionTime` ，请你按照上述要求，返回完成所有任务所需要的 **最少** 数目的 **工作时间段** 。

测试数据保证 `sessionTime` **大于等于** `tasks[i]` 中的 **最大值** 。

**示例 1：**

```shell
输入：tasks = [1,2,3], sessionTime = 3
输出：2
解释：你可以在两个工作时间段内完成所有任务。
- 第一个工作时间段：完成第一和第二个任务，花费 1 + 2 = 3 小时。
- 第二个工作时间段：完成第三个任务，花费 3 小时。
```

**示例 2：**

```shell
输入：tasks = [3,1,3,1,1], sessionTime = 8
输出：2
解释：你可以在两个工作时间段内完成所有任务。
- 第一个工作时间段：完成除了最后一个任务以外的所有任务，花费 3 + 1 + 3 + 1 = 8 小时。
- 第二个工作时间段，完成最后一个任务，花费 1 小时。
```

**示例 3：**

```shell
输入：tasks = [1,2,3,4,5], sessionTime = 15
输出：1
解释：你可以在一个工作时间段以内完成所有任务。
```

**提示：**

* n == tasks.length
* 1 <= n <= 14
* 1 <= tasks[i] <= 10
* max(tasks[i]) <= sessionTime <= 15

### 题解

## 前言

其实，状压 DP 就是枚举所有情况的 「 暴力 」。

本题的数据范围 `1 <= n <= 14` 在隐约地告诉我们，需要暴力地将所有情况算出来，取最优解。

## 思路

### 状态压缩

状态压缩，其实就是将每个任务 `task[i]` 看作某个 「 十进制数字 」 的**二进制上的第 `i` 位**，`1` 表示该任务被选择，反之不被选择。

根据上面的分析，我们可以得到完成所有任务的状态：`(1 << n) - 1`，其对应二进制位为 `n` 个 `1`。

Q：最小的花费怎么得到（Base Case）？

A：暴力地枚举每一个状态，计算当前状态选择的任务总耗时，如果没有超过 `sessionTime`，则代表该状态可以在 `1` 个时间段内完成。

Q：剩下的状态怎么得到最优解？

A：当然是在满足上述的两个条件后，由现有的 「 小子集 」 的最优解向 「 大子集 」 进行传递啦。

这里引入一个小技巧，枚举各个状态的「 二进制子集 」 ，枚举子集的时候可借机完成状态转移。

**枚举二进制子集**

```java
// m => 总状态数
for (int i = 1; i < m; i++) {
    // 枚举状态 i 的二进制子集
    for (int j = i; j > 0; j = (j - 1) & i) {
        // To Do..
    }
}
```

当然，不知道这个技巧也没关系，我们依然可以暴力地枚举 `i` 及之前的每个状态，如果这个状态是 `i` 的子集，则可以参与状态转移。

检查 `x` 是否为 `y` 的二进制子集：

`(x | y) == y`，即 `x` 对应二进制位上的 `1` 在 `y` 中的对应位置也是 `1`。

**暴力枚举二进制子集**

```java
// m => 总状态数
for (int i = 1; i < m; i++) {
    // 从 [1, i] 就可以了，后面的一定不会是 i 的子集
    for (int j = 1; j <= i; j++) {
        // 检查状态 j 是不是状态 i 的二进制子集
        if ((i | j) == i) {
            // To Do..
        }
    }
}
```

**Tips：** 需要注意的是，本题的状态 `0` 无意义，所以未枚举。其他的题需要分析状态 `0` 是否参与转移哦！

### 总结

由于第一层循环是 「 从小到大 」 往上遍历的，第一层循环的每个状态 i 通过在第二层循环枚举子集 j 时，会将子集 j 与补集 i ^ j 的最小消耗组合保留下来。

而保留下来的状态 `i` 的最优解又会成为后续某些状态 `i'` 的子集，故最后的 `dp[m]` 为完成所有任务的最小花费。

```java
class Solution {
    public int minSessions(int[] tasks, int sessionTime) {
        int n = tasks.length;
        int m = (1 << n) - 1;
        int INF = 20;
        int[] dp = new int[m + 1];
        Arrays.fill(dp, INF);

        // 预处理每个状态,合法的状态预设为1
        for (int i = 1; i <= m; i++) {
            int state = i;
            int index = 0;
            int spend = 0;

            // 计算每个状态的最优解
            while (state > 0) {
                if ((state & 1) == 1) {
                    spend += tasks[index];
                }
                state >>= 1;
                index++;
            }

            if (spend <= sessionTime) {
                dp[i] = 1;
            }
        }

        // 对每个状态枚举子集,对于已经有最优解(最优解的值为1)的状态,则不用处理
        for (int i = 1; i <= m; i++) {
            if (dp[i] == 1) {
                continue;
            }
            // 从 [1, i] 就可以了，后面的一定不会是 i 的子集
            for (int j = i; j > 0; j = (j - 1) & i) {
                // i 状态的最优解可能由当前子集 j 与子集 j 的补集得来
                dp[i] = Math.min(dp[i], dp[j] + dp[i ^ j]);
            }
        }

        return dp[m];
    }
}
```

