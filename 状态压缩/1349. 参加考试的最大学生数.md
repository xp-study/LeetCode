#### 1349. 参加考试的最大学生数

给你一个 `m * n` 的矩阵 `seats` 表示教室中的座位分布。如果座位是坏的（不可用），就用 `'#'` 表示；否则，用 `'.'` 表示。

学生可以看到左侧、右侧、左上、右上这四个方向上紧邻他的学生的答卷，但是看不到直接坐在他前面或者后面的学生的答卷。请你计算并返回该考场可以容纳的一起参加考试且无法作弊的最大学生人数。

学生必须坐在状况良好的座位上。

**示例 1：**

![img](./images/参加考试的最大学生数/1.jpg)

```shell
输入：seats = [["#",".","#","#",".","#"],
              [".","#","#","#","#","."],
              ["#",".","#","#",".","#"]]
输出：4
解释：教师可以让 4 个学生坐在可用的座位上，这样他们就无法在考试中作弊。 
```

**示例 2：**

```shell
输入：seats = [[".","#"],
              ["#","#"],
              ["#","."],
              ["#","#"],
              [".","#"]]
输出：3
解释：让所有学生坐在可用的座位上。
```

**示例 3：**

```shell
输入：seats = [["#",".",".",".","#"],
              [".","#",".","#","."],
              [".",".","#",".","."],
              [".","#",".","#","."],
              ["#",".",".",".","#"]]
输出：10
解释：让学生坐在第 1、3 和 5 列的可用座位上。
```

**提示：**

* seats 只包含字符 '.' 和'#'
* m == seats.length
* n == seats[i].length
* 1 <= m <= 8
* 1 <= n <= 8

### 题解

### 解题思路

`压缩状态DP，是将某一状态进行编码。例如一排座位有4个凳子，从右至左分别标号为0 —— 3.假设凳子有人坐表示1，没人坐表示0。那么其中一种状态是我自己坐在0号座位上(0001)，另一种状态是我坐在0号座位上，我女朋友坐在2号座位上(0101)。还有一种状态是我坐在0号座位上，我的三个前女友分别坐在123号座位上(1111)。那么可知，一共可以有16种状态。而这16种状态是由二进制表示可一一对应一个十进制的数字，那么就可以用这个十进制的数字来代表某一种状态。例如数字5表示0号和2号凳子有人坐(0101)。`

`回到这一题，要确定整个教室参加考试的最大人数，可将问题想成教室m横排的最大考试人数，那么前m - 1横排的最大人数加上第m排满足条件的最大人数就得到整个教室所能参加的最大人数。可是每一横排学生的排列不相同，所以我们将要遍历这一排学生可能坐的所有情况。假设这一横排有n个座位，那么就要遍历2^n次。于是我们定义数组dp[i][j] 表示第i + 1排(数组从0开始计数)的学生排列状态为十进制数j的情况下，前i排能够做最大学生人数加上j状态下对应的学生人数。(状态为十进制数j意思就是上面那个女朋友的例子)。`

`得到了dp数组的定义，就要看如何递推了。第i + 1排状态为j的dp[i][j]肯定和前一排有关系。如何得到dp[i][j]的最大值，就要将前一排的所有状态遍历一遍，将本排满足左上角右上角没人的前一排的状态都挑选出来，再选出一个最大值得到第i + 1排状态为j的dp[i][j]的值。`

```java
for(int k = 0; k < stateSize; k++){
    if(左上角右上角没有学生){
        dp[i][j] = Math.max(dp[i - 1][k] + Integer.bitCount(j) , dp[i][j]);
    }
}
```

解决了DP数组定义和状态转移方程，接下来就是具体实现细节了。

Q1：如何计算状态j情况下的学生人头数？

A：利用java函数Integer.bitCount(j),j的二进制有多少1，就返回具体个数，即学生人头数。

Q2：如何计算状态j情况下左右没有人？

A：利用位运算，将j左移一位和j进行按位与如果为0，则说明二进制的j中没有相邻的二进制1，则说明左右无人。即：`(j & (j >> 1)) == 0`。

Q3：如何计算状态j情况下左上方右上方无人？

A：将前一排的状态k右移一位和j按位与，如果等于0，则说明状态k二进制1不会存在于状态j的左上方。
将前一排的状态k左移一位和j按位与，如果等于0，则说明状态k二进制1不会存在于状态j的右上方。
j & (k >> 1)) == 0 && ((j >> 1) & k) == 0

Q4：如何表示好的座椅？题中桌椅的好坏是用字符表示的。

A：设置一个表示座椅是否可用的数组validity[m]，将每一排的可用桌椅表示状态并压缩。类似前面女朋友的例子。好的桌椅表示1，坏的表示0.那么当遍历不同学生状态j时，只需要将学生状态j和桌椅状态按位相遇即可，若等于j。表示当钱学生状态可坐进这一排的座位中。j & validity[i] == j

```java
class Solution {
    public int maxStudents(char[][] seats) {
        int m = seats.length;
        int n = seats[0].length;


        // 每一横排可由学生排布的方式有2^n种。
        int stateSize = (1 << n) - 1;

        // validity数组用于记录每一横排位置是否能做。
        int[] validity = new int[m];
        // 初始化validity数组
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                validity[i] = (validity[i] << 1) + (seats[i][j] == '.' ? 1 : 0);
            }
        }


        int[][] dp = new int[m][stateSize+1];
        // 初始化dp数组
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                dp[i][j] = -1;
            }
        }

        int ans = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= stateSize; j++) {
                // j & validity[i] == j 判断j的状态下能否坐下第i横排
                // (j & (j >> 1) == 0) 判断j模式左右是否没人
                if (((j & validity[i]) == j) && (j & (j << 1)) == 0) {
                    // 第一横排
                    if (i == 0) {
                        dp[i][j] = Integer.bitCount(j);
                    } else {
                        // 不是第一排，就要遍历前一排，从而取得当前排的最大值。
                        for (int k = 0; k <= stateSize; k++) {
                            if (dp[i - 1][k] != -1 && (j & (k << 1)) == 0 && (j & (k >> 1)) == 0) {
                                dp[i][j] = Math.max(dp[i][j], dp[i - 1][k] + Integer.bitCount(j));
                            }
                        }
                    }
                    ans = Math.max(ans, dp[i][j]);
                }
            }
        }
        return ans;
    }
}
```

