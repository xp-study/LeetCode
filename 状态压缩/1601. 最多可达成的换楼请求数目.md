#### 1601. 最多可达成的换楼请求数目

我们有 `n` 栋楼，编号从 `0` 到 `n - 1` 。每栋楼有若干员工。由于现在是换楼的季节，部分员工想要换一栋楼居住。

给你一个数组 requests ，其中 requests[i] = [fromi, toi] ，表示一个员工请求从编号为 fromi 的楼搬到编号为 toi 的楼。

一开始 所有楼都是满的，所以从请求列表中选出的若干个请求是可行的需要满足 每栋楼员工净变化为 0 。意思是每栋楼 离开 的员工数目 等于 该楼 搬入 的员工数数目。比方说 n = 3 且两个员工要离开楼 0 ，一个员工要离开楼 1 ，一个员工要离开楼 2 ，如果该请求列表可行，应该要有两个员工搬入楼 0 ，一个员工搬入楼 1 ，一个员工搬入楼 2 。

请你从原请求列表中选出若干个请求，使得它们是一个可行的请求列表，并返回所有可行列表中最大请求数目。

**示例 1：**

![img](http://gitlab.wsh-study.com/xp-study/LeeteCode/blob/master/状态压缩/images/最多可达成的换楼请求数目/1.jpg)

```shell
输入：n = 5, requests = [[0,1],[1,0],[0,1],[1,2],[2,0],[3,4]]
输出：5
解释：请求列表如下：
从楼 0 离开的员工为 x 和 y ，且他们都想要搬到楼 1 。
从楼 1 离开的员工为 a 和 b ，且他们分别想要搬到楼 2 和 0 。
从楼 2 离开的员工为 z ，且他想要搬到楼 0 。
从楼 3 离开的员工为 c ，且他想要搬到楼 4 。
没有员工从楼 4 离开。
我们可以让 x 和 b 交换他们的楼，以满足他们的请求。
我们可以让 y，a 和 z 三人在三栋楼间交换位置，满足他们的要求。
所以最多可以满足 5 个请求。
```

**示例 2：**

![img](http://gitlab.wsh-study.com/xp-study/LeeteCode/blob/master/状态压缩/images/最多可达成的换楼请求数目/2.jpg)

```shell
输入：n = 3, requests = [[0,0],[1,2],[2,1]]
输出：3
解释：请求列表如下：
从楼 0 离开的员工为 x ，且他想要回到原来的楼 0 。
从楼 1 离开的员工为 y ，且他想要搬到楼 2 。
从楼 2 离开的员工为 z ，且他想要搬到楼 1 。
我们可以满足所有的请求。
```

**提示：**

* 1 <= n <= 20
* 1 <= requests.length <= 16
* requests[i].length == 2
* 0 <= fromi, toi < n

### 题解

这个问题翻到最后的数据范围，requests 最大只有 16！这意味着我们枚举所有请求的组合，也不过有 1 << 16 = 65536 种可能。对于每种请求的组合，我们只需要检查一下这个组合是否可以满足。一旦可以满足，记录最大的请求数量即可。

枚举所有请求的组合，可以直接使用状态压缩。用一个数字 state 表示一组请求的组合，state 的二进制表示中，1 代表采用这个请求，0 代表忽略这个请求。这样，遍历所有的请求的组合，只需要 state 从 0 检查到 1 << (请求总数)（最大是 65536）即可。

对于某一个 state，检查的方法也非常简单。我们用out[k]表示有多少人想从k号楼出来；用in[k]表示有多少人想搬入k号楼。对于每一个我们需要考虑的请求(from, to)，out[from] ++，in[to] --。最后，out 和 in 数组中的对应元素都相等，说明这样一组请求可以被满足。

```java
class Solution {
    public int maximumRequests(int n, int[][] requests) {
        int m = requests.length;
        int max = (1 << m) - 1;

        int ans = 0;
        int[] changes = new int[n];

        // 枚举所有状态,二进制中对应位置上的值为1,代表当前请求被采用
        for (int i = 1; i <= max; i++) {
            int[] tempChange = new int[n];
            int state = i;
            int index = 0;
            int requestCount = 0;
            while (state > 0) {
                if ((state & 1) == 1) {
                    int from = requests[index][0];
                    int to = requests[index][1];
                    tempChange[from]--;
                    tempChange[to]++;
                    requestCount++;
                }
                state >>= 1;
                index++;
            }
            // 完成状态内的所有请求后，每栋楼员工净变化为 0
            // 即数组全为 0
            if (Arrays.equals(tempChange, changes)) {
                ans = Math.max(ans, requestCount);
            }
        }
        return ans;
    }
}
```

