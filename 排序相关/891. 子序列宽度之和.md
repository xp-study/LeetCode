#### 891. 子序列宽度之和

给定一个整数数组 `A` ，考虑 `A` 的所有非空子序列。

对于任意序列 S ，设 S 的宽度是 S 的最大元素和最小元素的差。

返回 A 的所有子序列的宽度之和。

由于答案可能非常大，请**返回答案模 10^9+7**。

**示例：**

```shell
输入：[2,1,3]
输出：6
解释：
子序列为 [1]，[2]，[3]，[2,1]，[2,3]，[1,3]，[2,1,3] 。
相应的宽度是 0，0，0，1，1，2，2 。
这些宽度之和是 6 。
```

**提示：**

- `1 <= A.length <= 20000`
- `1 <= A[i] <= 20000`

### 题解

### 解题思路

我们可以对数组进行排序，因为这并不会改变答案。

排完序之后，我们可以观察到：一个元素是最大元素：当且仅当它是被选取元素中最右边的一个；一个元素是最小元素，当且仅当它是被选取元素中最左边的一个。

所以说，假设排序后一个元素左边有left个元素，右边有right个元素，那么这个元素作为最小值出现的子序列一共有2^{right}个（右边的每个元素可以选取或不选取）；而作为最大值出现的子序列一共有2^{left}个。因此，元素A[i]对最后的总和的贡献就等于：

(2^{left}-2^{right})⋅*A*[*i*]=(2^{i}-2^{N-1-i})⋅*A*[*i*]

那么，我们只要预先计算好2的各个幂次的值，就能很轻松地求出最后的结果了。

```java
class Solution {
    public int sumSubseqWidths(int[] A) {
        int MOD = 1000000000 + 7;
        int N = A.length;
        Arrays.sort(A);

        long[] pow2 = new long[N];
        pow2[0] = 1;

        for (int i = 1; i < N; i++) {
            pow2[i] = pow2[i - 1] * 2 % MOD;
        }

        long ans = 0;
        for (int i = 0; i < N; i++) {
            ans = (ans+(pow2[i] - pow2[N - 1 - i]) * A[i] )% MOD;
        }
        return (int)ans;
    }
}
```

