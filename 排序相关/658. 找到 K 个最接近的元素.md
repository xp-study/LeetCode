#### 658. 找到 K 个最接近的元素

给定一个排序好的数组 `arr` ，两个整数 `k` 和 `x` ，从数组中找到最靠近 `x`（两数之差最小）的 `k` 个数。返回的结果必须要是按升序排好的。

整数 `a` 比整数 `b` 更接近 `x` 需要满足：

- `|a - x| < |b - x|` 或者
- `|a - x| == |b - x|` 且 `a < b`

**示例 1：**

```shell
输入：arr = [1,2,3,4,5], k = 4, x = 3
输出：[1,2,3,4]
```

**示例 2：**

```shell
输入：arr = [1,2,3,4,5], k = 4, x = -1
输出：[1,2,3,4]
```

**提示：**

- `1 <= k <= arr.length`
- `1 <= arr.length <= 104`
- 数组里的每个元素与 `x` 的绝对值不超过 `104`

### 题解

## 方法一：排除法（双指针）

以 `arr = [1, 2, 3, 4, 5, 6, 7]` , `x = 5`, `k = 3` 为例。

**思路分析**：

* 一个一个删，因为是有序数组，且返回的是连续升序子数组，所以 **每一次删除的元素一定位于边界** ；
* 一共 7 个元素，要保留 33 个元素，因此要删除 4 个元素；
* 因为要删除的元素都位于边界，于是可以使用 **双指针** 对撞的方式确定保留区间，即「最优区间」。

我们再分析一个 `x` 不在数组中的例子，例如：

数组 arr = [0, 1, 2, 3, 3, 4, 7, 7, 8]，k = 3，x = 5。数组中一共 9 个数，保留 3 个数，则需要删除 6 个数，这里 6 = len(arr) - k。

- 因为 `5 - 0 > 8 - 5`，所以将 0 删去；
- 因为 `5 - 1 > 8 - 5`，所以将 1 删去；
- 因为 `5 - 2 = 8 - 5`，根据题目意思，保留左边的 2 ，所以将 88 删去；
- 因为 `5 - 2 > 7 - 5`，所以将 2 删去；
- 因为 `5 - 3 = 7 - 5`，根据题目意思，保留左边的 3 ，所以将 77 删去；
- 因为 `5 - 3 = 7 - 5`，根据题目意思，保留左边的 3 ，所以将 77 删去；

已经删除了 6 个数，剩下的 `[3, 3, 4]` 就是最接近 5 的 3 个数。

```java
class Solution {
    public List<Integer> findClosestElements(int[] arr, int k, int x) {
        int n = arr.length;
        int left = 0;
        int right = n - 1;

        int removeNums = n - k;

        while (removeNums > 0) {
            if ((x - arr[left]) <= (arr[right] - x)) {
                right--;
            } else {
                left++;
            }
            removeNums--;
        }
        List<Integer> res = new ArrayList<>();
        for (int i = left; i < left + k; i++) {
            res.add(arr[i]);
        }
        return res;
    }
}
```

