#### 1959. K 次调整数组大小浪费的最小总空间

你正在设计一个动态数组。给你一个下标从 0 开始的整数数组 nums ，其中 nums[i] 是 i 时刻数组中的元素数目。除此以外，你还有一个整数 k ，表示你可以 调整 数组大小的 最多 次数（每次都可以调整成 任意 大小）。

t 时刻数组的大小 sizet 必须大于等于 nums[t] ，因为数组需要有足够的空间容纳所有元素。t 时刻 浪费的空间 为 sizet - nums[t] ，总 浪费空间为满足 0 <= t < nums.length 的每一个时刻 t 浪费的空间 之和 。

在调整数组大小不超过 k 次的前提下，请你返回 最小总浪费空间 。

注意：数组最开始时可以为 任意大小 ，且 不计入 调整大小的操作次数。

**示例 1：**

```shell
输入：nums = [10,20], k = 0
输出：10
解释：size = [20,20].
我们可以让数组初始大小为 20 。
总浪费空间为 (20 - 10) + (20 - 20) = 10 。
```

**示例 2：**

```shell
输入：nums = [10,20,30], k = 1
输出：10
解释：size = [20,20,30].
我们可以让数组初始大小为 20 ，然后时刻 2 调整大小为 30 。
总浪费空间为 (20 - 10) + (20 - 20) + (30 - 30) = 10 。
```

**示例 3：**

```shell
输入：nums = [10,20,15,30,20], k = 2
输出：15
解释：size = [10,20,20,30,30].
我们可以让数组初始大小为 10 ，时刻 1 调整大小为 20 ，时刻 3 调整大小为 30 。
总浪费空间为 (10 - 10) + (20 - 20) + (20 - 15) + (30 - 30) + (30 - 20) = 15 。
```

**提示：**

- `1 <= nums.length <= 200`
- `1 <= nums[i] <= 106`
- `0 <= k <= nums.length - 1`

### 题解

#### 方法一：动态规划 + 预处理

**思路与算法**

题目描述等价于：

> 给定数组 nums 以及整数 k，需要把数组完整地分成 k+1 段连续的子数组，每一段的权值是「这一段的最大值乘以这一段的长度再减去这一段的元素和」。需要最小化总权值。
>

我们可以使用动态规划解决本题。

```java
class Solution {
    public int minSpaceWastedKResizing(int[] nums, int k) {
        int n = nums.length;
        int MaxValue = Integer.MAX_VALUE;

        // 数组g表示数组下标从i到j的均值和
        // 均值和的定义为数组下标从i到j的最大值x区间数字个数-区间和的值
        long[][] g = new long[n][n];
        for (int i = 0; i < n; i++) {
            int max = nums[i];
            long sum = nums[i];
            for (int j = i + 1; j < n; j++) {
                max = Math.max(max, nums[j]);
                sum += nums[j];
                g[i][j] = max * (j - i + 1) - sum;
            }
        }

        // dp[i][j]表示数组下标从0到i(左闭右闭区间)切分为j段的均值和
        long[][] dp = new long[n][k + 2];

        // 初始化动态规划数组
        for (int i = 0; i < n; i++) {
            Arrays.fill(dp[i], MaxValue);
        }

        // 数组下标从0到0的数字,均值和为0
        for (int i = 0; i <= k + 1; i++) {
            dp[0][i] = 0;
        }

        for (int i = 0; i < n; i++) {
            // 数组下标从0到i的数字,切分为0段的均值和为0
            dp[i][0] = 0;
            // 数组下标从0到i的数字,切分为1段的均值和为g[0][i]
            dp[i][1] = g[0][i];
        }

        //  dp[i][j] = Math.min(dp[i][j], dp[i0 - 1][j - 1] + g[i0][i])
        for (int i = 1; i < n; i++) {
            for (int j = 2; j <= k + 1; j++) {
                for (int i0 = 1; i0 <= i; i0++) {
                    dp[i][j] = Math.min(dp[i][j], dp[i0 - 1][j - 1] + g[i0][i]);
                }
            }
        }
        return (int) dp[n - 1][k + 1];
    }
}
```

