#### 1987. 不同的好子序列数目

给你一个二进制字符串 binary 。 binary 的一个 子序列 如果是 非空 的且没有 前导 0 （除非数字是 "0" 本身），那么它就是一个 好 的子序列。

请你找到 `binary` **不同好子序列** 的数目。

* 比方说，如果 binary = "001" ，那么所有 好 子序列为 ["0", "0", "1"] ，所以 不同 的好子序列为 "0" 和 "1" 。 注意，子序列 "00" ，"01" 和 "001" 不是好的，因为它们有前导 0 。

  

请你返回 `binary` 中 **不同好子序列** 的数目。由于答案可能很大，请将它对 `109 + 7` **取余** 后返回。

一个 **子序列** 指的是从原数组中删除若干个（可以一个也不删除）元素后，不改变剩余元素顺序得到的序列。

**示例 1：**

```shell
输入：binary = "001"
输出：2
解释：好的二进制子序列为 ["0", "0", "1"] 。
不同的好子序列为 "0" 和 "1" 。
```

**示例 2：**

```shell
输入：binary = "11"
输出：2
解释：好的二进制子序列为 ["1", "1", "11"] 。
不同的好子序列为 "1" 和 "11" 。
```

**示例 3：**

```shell
输入：binary = "101"
输出：5
解释：好的二进制子序列为 ["1", "0", "1", "10", "11", "101"] 。
不同的好子序列为 "0" ，"1" ，"10" ，"11" 和 "101" 。
```

**提示：**

- `1 <= binary.length <= 105`
- `binary` 只含有 `'0'` 和 `'1'` 。

### 题解

**定义**

因为我们关心子序列的 **开头** 是什么，所以我们这样定义：

`dp[i][0]= 字符串 binary 的从 i开始的子串中，以 0 开头的子序列的个数`

`dp[i][1]= 字符串 binary 的从 i开始的子串中，以 1 开头的子序列的个数`

**状态转移**

我们从后向前遍历字符串 binary 。

* `当 binary[i] == '0' 时，dp[i][0] 的求解可以分成 2 个部分：`
  * `第一部分：这个 '0' 可以添加到所有的子序列的前面，此部分共有 dp[i+1][0] + dp[i+1][1]个不同的子序列。`
  * 第二部分 ：单独的 1 个 0。

`因此，dp[i][0]= 第一部分 + 第二部分 = dp[i+1][0] + dp[i+1][1] + 1。`

`然后，由于 binary[i] == '0'，故 dp[i][1] 不会发生变化，dp[i][1] = dp[i+1][1]。`

* 当 binary[i] == '1' 时，同理可推

`dp[i][1]=dp[i+1][0]+dp[i+1][1]+1`

`dp[i][0] = dp[i+1][0]`

**最终答案**

`最终答案就是，全部以 1 开头的子序列的个数（也就是 dp[0][1]）+ 字符串 “0” （如果有）。`

```java
class Solution {
    public int numberOfUniqueGoodSubsequences(String binary) {
        int MOD = 1000000000 + 7;
        int n = binary.length();
        int hasZero = 0;
        int[][] dp = new int[n][2];

        char[] charArray = binary.toCharArray();

        dp[n - 1][0] = charArray[n - 1] == '0' ? 1 : 0;
        dp[n - 1][1] = charArray[n - 1] == '0' ? 0 : 1;

        if (charArray[n - 1] == '0') {
            hasZero = 1;
        }

        for (int i = n - 2; i >= 0; i--) {
            if (charArray[i] == '0') {
                dp[i][0] = (dp[i + 1][0] + dp[i + 1][1] + 1) % MOD;
                dp[i][1] = dp[i + 1][1];
                hasZero = 1;
            } else {
                dp[i][1] = (dp[i + 1][0] + dp[i + 1][1] + 1) % MOD;
                dp[i][0] = dp[i + 1][0];
            }
        }

        return (dp[0][1] + hasZero) % MOD;
    }
}
```

