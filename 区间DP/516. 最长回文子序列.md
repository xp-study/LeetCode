#### 516. 最长回文子序列

给你一个字符串 `s` ，找出其中最长的回文子序列，并返回该序列的长度。

子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。

**示例 1：**

```shell
输入：s = "bbbab"
输出：4
解释：一个可能的最长回文子序列为 "bbbb" 。
```

**示例 2：**

```shell
输入：s = "cbbd"
输出：2
解释：一个可能的最长回文子序列为 "bb" 。
```

**提示：**

- `1 <= s.length <= 1000`
- `s` 仅由小写英文字母组成

### 题解

### 1，动态规划解决

注意这里是求最长回文子序列不是回文子串，子串必须是连续的，但子序列不一定是连续的。

我们定义**dp[i] [j]表示字符串中从i到j之间的最长回文子序列**。

​	1. 如果**s.charAt(i) == s.charAt(j)**，也就是说两头的字符是一样的，他们可以和中间的最长回文子序列构成一个更长的回文子序列，即

**dp[i] [j]=dp[i+1] [j-1]+2**

如下图所示

![640.png](http://gitlab.wsh-study.com/xp-study/LeeteCode/-/blob/master/区间DP/images/最长回文子序列/1.jpg)

2. 如果s.charAt(i) != s.charAt(j)，说明i和j指向的字符是不相等的，我们可以截取，要么去掉i指向的字符，要么去掉j指向的字符，然后取最大值，即
   dp[i] [j] = Math.max(dp[i] [j-1], dp[i+1] [j])

如下图所示

![image.png](http://gitlab.wsh-study.com/xp-study/LeeteCode/-/blob/master/区间DP/images/最长回文子序列/2.jpg)

有了递推公式，我们再来看下`Base case`，就是一个字符也是回文串，即`dp[i][i]=1`；

注意二维数组`dp[i][j]`的定义，如果`i>j`是没有意义的。再来看一下他们之间的关系

![image.png](http://gitlab.wsh-study.com/xp-study/LeeteCode/-/blob/master/区间DP/images/最长回文子序列/3.jpg)

从上面图中可以看出如果我们想求dp[i][j]，那么其他3个必须都是已知的，很明显从上往下遍历是不行的，我们只能让i从最后一个字符往前遍历，j从i的下一个开始遍历，最后只需要返回dp[0] [length - 1]即可。来看下代码

```java
public int longestPalindromeSubseq(String s) {
    int length = s.length();
    int[][] dp = new int[length][length];
    //这里i要从最后一个开始遍历
    for (int i = length - 1; i >= 0; i--) {
        //单个字符也是一个回文串
        dp[i][i] = 1;
        //j从i的下一个开始
        for (int j = i + 1; j < length; j++) {
            //下面是递推公式
            if (s.charAt(i) == s.charAt(j)) {
                dp[i][j] = dp[i + 1][j - 1] + 2;
            } else {
                dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[0][length - 1];
}
```

### 补充

可能有些同学还看不懂`i`为什么要倒序，我画了个图。我们看下如果要求`d`，必须先知道`a，b，c`的值，如果不倒序，计算`d`的时候，`b`和`c`的值还是未知的。

![image.png](http://gitlab.wsh-study.com/xp-study/LeeteCode/-/blob/master/区间DP/images/最长回文子序列/4.jpg)

倒序如下图所示，倒叙也就是`从下到上，从左到右`的顺序，这样才能保证计算`d`的时候，`a，b，c`的值都已经计算过了。

![image.png](http://gitlab.wsh-study.com/xp-study/LeeteCode/-/blob/master/区间DP/images/最长回文子序列/5.jpg)