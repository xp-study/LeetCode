#### 630. 课程表 III

这里有 n 门不同的在线课程，他们按从 1 到 n 编号。每一门课程有一定的持续上课时间（课程时间）t 以及关闭时间第 d 天。一门课要持续学习 t 天直到第 d 天时要完成，你将会从第 1 天开始。

给出 `n` 个在线课程用 `(t, d)` 对表示。你的任务是找出最多可以修几门课。

**示例：**

```shell
输入: [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]]
输出: 3
解释: 
这里一共有 4 门课程, 但是你最多可以修 3 门:
首先, 修第一门课时, 它要耗费 100 天，你会在第 100 天完成, 在第 101 天准备下门课。
第二, 修第三门课时, 它会耗费 1000 天，所以你将在第 1100 天的时候完成它, 以及在第 1101 天开始准备下门课程。
第三, 修第二门课时, 它会耗时 200 天，所以你将会在第 1300 天时完成它。
第四门课现在不能修，因为你将会在第 3300 天完成它，这已经超出了关闭日期。	
```

**提示:**

1. 整数 1 <= d, t, n <= 10,000 。
2. 你不能同时修两门课程。

### 题解

### 解题思路

这种和活动时间安排，会议室预定差不多，就是贪心的思想
贪心的关键点就是：根据谁结束的早来选，选结束的早的，自然能学的课程也就越多

```java
class Solution {
    public int scheduleCourse(int[][] courses) {
        // 按照课程的关闭时间从早到晚排序
        Arrays.sort(courses, (a, b) -> a[1] - b[1]);
        // 用一个优先队列存储每门课的持续上课时间，从大到小排，默认是从小到大排，也就是队首元素是最大的
        PriorityQueue<Integer> maxHeep = new PriorityQueue<>((a, b) -> b - a);
        int now = 0;

        for (int[] course : courses) {
            // 如果目前为止所有课程总时间小于等于当前所学课程的关闭时间，那么
            // 当前课程可学，否则不可学
            if (now + course[0] <= course[1]) {
                maxHeep.add(course[0]);
                now += course[0];

                // 如果当前课程不可学，不意味着就只能学这么多了，因为有可能是之前的课程里有持续时间太长的
                // 课程，导致超过关闭时间。因此可以将当前课程上课时间与之前所学课程中最长的上课时间进行比较
                // 如果当前小于之前的，那么可以替换，从而有进一步学习的可能性，否则，那么就无法继续学习
                // 这门课
            } else if (!maxHeep.isEmpty() && maxHeep.peek() > course[0]) {
                now += course[0] - maxHeep.poll();
                maxHeep.add(course[0]);
            }
        }
        return maxHeep.size();
    }
}
```

