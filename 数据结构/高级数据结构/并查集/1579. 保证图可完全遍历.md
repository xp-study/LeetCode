#### 1579. 保证图可完全遍历

Alice 和 Bob 共有一个无向图，其中包含 n 个节点和 3 种类型的边：

- 类型 1：只能由 Alice 遍历。
- 类型 2：只能由 Bob 遍历。
- 类型 3：Alice 和 Bob 都可以遍历。

给你一个数组 edges ，其中 edges[i] = [typei, ui, vi] 表示节点 ui 和 vi 之间存在类型为 typei 的双向边。请你在保证图仍能够被 Alice和 Bob 完全遍历的前提下，找出可以删除的最大边数。如果从任何节点开始，Alice 和 Bob 都可以到达所有其他节点，则认为图是可以完全遍历的。

返回可以删除的最大边数，如果 Alice 和 Bob 无法完全遍历图，则返回 -1 。

**示例 1：**

![img](http://gitlab.wsh-study.com/xp-study/LeeteCode/-/blob/master/数据结构/高级数据结构/并查集/images/保证图可完全遍历/1.jpg)

```shell
输入：n = 4, edges = [[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]]
输出：2
解释：如果删除 [1,1,2] 和 [1,1,3] 这两条边，Alice 和 Bob 仍然可以完全遍历这个图。再删除任何其他的边都无法保证图可以完全遍历。所以可以删除的最大边数是 2 
```

**示例 2：**

![img](http://gitlab.wsh-study.com/xp-study/LeeteCode/-/blob/master/数据结构/高级数据结构/并查集/images/保证图可完全遍历/2.jpg)

```shell
输入：n = 4, edges = [[3,1,2],[3,2,3],[1,1,4],[2,1,4]]
输出：0
解释：注意，删除任何一条边都会使 Alice 和 Bob 无法完全遍历这个图。
```

**示例 3：**

![img](http://gitlab.wsh-study.com/xp-study/LeeteCode/-/blob/master/数据结构/高级数据结构/并查集/images/保证图可完全遍历/3.jpg)

```shell
输入：n = 4, edges = [[3,2,3],[1,1,2],[2,3,4]]
输出：-1
解释：在当前图中，Alice 无法从其他节点到达节点 4 。类似地，Bob 也不能达到节点 1 。因此，图无法完全遍历。
```

**提示：**

* `1 <= n <= 10^5`
* `1 <= edges.length <= min(10^5, 3 * n * (n-1) / 2)`
* `edges[i].length == 3`
* `1 <= edges[i][0] <= 3`
* `1 <= edges[i][1] < edges[i][2] <= n`
* `所有元组 (typei, ui, vi) 互不相同`

### 题解

**贪心+并查集**

**先处理公共边,优先保留公共边**

```java
class Solution {
    public int maxNumEdgesToRemove(int n, int[][] edges) {
        UnionFind unionFindA = new UnionFind(n + 1);
        UnionFind unionFindB = new UnionFind(n + 1);


        // 再遍历公共边,找出对Alice来说多余的公共边
        Set<Integer> set = new HashSet<>();
        for (int i = 0; i < edges.length; i++) {
            int[] edge = edges[i];

            if (edge[0] != 3) {
                continue;
            }

            if (!unionFindA.isConnected(edge[1], edge[2])) {
                unionFindA.union(edge[1], edge[2]);
            } else {
                set.add(i);
            }
        }

        int ans = 0;
        // 先遍历只有Alice访问的边
        for (int i = 0; i < edges.length; i++) {
            int[] edge = edges[i];

            if (edge[0] != 1) {
                continue;
            }

            if (!unionFindA.isConnected(edge[1], edge[2])) {
                unionFindA.union(edge[1], edge[2]);
            } else {
                ans++;
            }
        }


        for (int i = 0; i < edges.length; i++) {
            int[] edge = edges[i];

            if (edge[0] != 3) {
                continue;
            }

            if (!unionFindB.isConnected(edge[1], edge[2])) {
                unionFindB.union(edge[1], edge[2]);
            } else {
                if (set.contains(i)) {
                    ans++;
                }
            }
        }

        // 遍历只有Bob能遍历的边
        for (int i = 0; i < edges.length; i++) {
            int[] edge = edges[i];

            if (edge[0] != 2) {
                continue;
            }

            if (!unionFindB.isConnected(edge[1], edge[2])) {
                unionFindB.union(edge[1], edge[2]);
            } else {
                ans++;
            }
        }



        if (unionFindA.getCount() != 2 || unionFindB.getCount() != 2) {
            return -1;
        }

        return ans;
    }


    private class UnionFind {
        public int[] parent;
        public int[] rank;
        public int count;


        public void split(int element) {
            parent[element] = element;
        }

        public UnionFind(int size) {
            this.parent = new int[size];
            this.rank = new int[size];
            this.count = size;

            for (int i = 0; i < size; ++i) {
                parent[i] = i;
            }

            for (int i = 0; i < size; i++) {
                rank[i] = 1;
            }
        }

        public boolean isConnected(int u, int v) {
            int rootu = find(u);
            int rootv = find(v);
            return rootu == rootv;
        }

        public int find(int element) {
            if (parent[element] == element) {
                return element;
            }

            return parent[element] = find(parent[element]);
        }

        public void union(int element1, int element2) {
            int rootx = find(element1);
            int rooty = find(element2);
            if (rootx != rooty) {
                if (rank[rootx] > rank[rooty]) {
                    parent[rooty] = rootx;
                } else if (rank[rootx] < rank[rooty]) {
                    parent[rootx] = rooty;
                } else {
                    parent[rooty] = rootx;
                    rank[rootx] += 1;
                }
                count--;
            }
        }

        public int getCount() {
            return count;
        }
    }
}
```

