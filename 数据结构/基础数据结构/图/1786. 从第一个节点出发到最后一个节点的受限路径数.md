#### 1786. ä»ç¬¬ä¸€ä¸ªèŠ‚ç‚¹å‡ºå‘åˆ°æœ€åä¸€ä¸ªèŠ‚ç‚¹çš„å—é™è·¯å¾„æ•°

`ç°æœ‰ä¸€ä¸ªåŠ æƒæ— å‘è¿é€šå›¾ã€‚ç»™ä½ ä¸€ä¸ªæ­£æ•´æ•° n ï¼Œè¡¨ç¤ºå›¾ä¸­æœ‰ n ä¸ªèŠ‚ç‚¹ï¼Œå¹¶æŒ‰ä» 1 åˆ° n ç»™èŠ‚ç‚¹ç¼–å·ï¼›å¦ç»™ä½ ä¸€ä¸ªæ•°ç»„ edges ï¼Œå…¶ä¸­æ¯ä¸ª edges[i] = [ui, vi, weighti] è¡¨ç¤ºå­˜åœ¨ä¸€æ¡ä½äºèŠ‚ç‚¹ ui å’Œ vi ä¹‹é—´çš„è¾¹ï¼Œè¿™æ¡è¾¹çš„æƒé‡ä¸º weighti ã€‚`

`ä»èŠ‚ç‚¹ start å‡ºå‘åˆ°èŠ‚ç‚¹ end çš„è·¯å¾„æ˜¯ä¸€ä¸ªå½¢å¦‚ [z0, z1, z2, ..., zk] çš„èŠ‚ç‚¹åºåˆ—ï¼Œæ»¡è¶³ z0 = start ã€zk = end ä¸”åœ¨æ‰€æœ‰ç¬¦åˆ 0 <= i <= k-1 çš„èŠ‚ç‚¹ zi å’Œ zi+1 ä¹‹é—´å­˜åœ¨ä¸€æ¡è¾¹ã€‚`

`è·¯å¾„çš„è·ç¦»å®šä¹‰ä¸ºè¿™æ¡è·¯å¾„ä¸Šæ‰€æœ‰è¾¹çš„æƒé‡æ€»å’Œã€‚ç”¨ distanceToLastNode(x) è¡¨ç¤ºèŠ‚ç‚¹ n å’Œ x ä¹‹é—´è·¯å¾„çš„æœ€çŸ­è·ç¦»ã€‚å—é™è·¯å¾„ ä¸ºæ»¡è¶³ distanceToLastNode(zi) > distanceToLastNode(zi+1) çš„ä¸€æ¡è·¯å¾„ï¼Œå…¶ä¸­ 0 <= i <= k-1 ã€‚`

è¿”å›ä»èŠ‚ç‚¹ `1` å‡ºå‘åˆ°èŠ‚ç‚¹ `n` çš„ **å—é™è·¯å¾„æ•°** ã€‚ç”±äºæ•°å­—å¯èƒ½å¾ˆå¤§ï¼Œè¯·è¿”å›å¯¹ `109 + 7` **å–ä½™** çš„ç»“æœã€‚

**ç¤ºä¾‹ 1ï¼š**

![img](http://gitlab.wsh-study.com/xp-study/LeeteCode/-/blob/master/æ•°æ®ç»“æ„/åŸºç¡€æ•°æ®ç»“æ„/å›¾/images/ä»ç¬¬ä¸€ä¸ªèŠ‚ç‚¹å‡ºå‘åˆ°æœ€åä¸€ä¸ªèŠ‚ç‚¹çš„å—é™è·¯å¾„æ•°/1.jpg)

```shell
è¾“å…¥ï¼šn = 5, edges = [[1,2,3],[1,3,3],[2,3,1],[1,4,2],[5,2,2],[3,5,1],[5,4,10]]
è¾“å‡ºï¼š3
è§£é‡Šï¼šæ¯ä¸ªåœ†åŒ…å«é»‘è‰²çš„èŠ‚ç‚¹ç¼–å·å’Œè“è‰²çš„ distanceToLastNode å€¼ã€‚ä¸‰æ¡å—é™è·¯å¾„åˆ†åˆ«æ˜¯ï¼š
1) 1 --> 2 --> 5
2) 1 --> 2 --> 3 --> 5
3) 1 --> 3 --> 5
```

**ç¤ºä¾‹ 2ï¼š**

![img](http://gitlab.wsh-study.com/xp-study/LeeteCode/-/blob/master/æ•°æ®ç»“æ„/åŸºç¡€æ•°æ®ç»“æ„/å›¾/images/ä»ç¬¬ä¸€ä¸ªèŠ‚ç‚¹å‡ºå‘åˆ°æœ€åä¸€ä¸ªèŠ‚ç‚¹çš„å—é™è·¯å¾„æ•°/2.jpg)

```shell
è¾“å…¥ï¼šn = 7, edges = [[1,3,1],[4,1,2],[7,3,4],[2,5,3],[5,6,1],[6,7,2],[7,5,3],[2,6,4]]
è¾“å‡ºï¼š1
è§£é‡Šï¼šæ¯ä¸ªåœ†åŒ…å«é»‘è‰²çš„èŠ‚ç‚¹ç¼–å·å’Œè“è‰²çš„ distanceToLastNode å€¼ã€‚å”¯ä¸€ä¸€æ¡å—é™è·¯å¾„æ˜¯ï¼š1 --> 3 --> 7 ã€‚
```

**æç¤ºï¼š**

* 1 <= n <= 2 * 104
* n - 1 <= edges.length <= 4 * 104
* edges[i].length == 3
* 1 <= ui, vi <= n
* ui != vi
* 1 <= weighti <= 105
* ä»»æ„ä¸¤ä¸ªèŠ‚ç‚¹ä¹‹é—´è‡³å¤šå­˜åœ¨ä¸€æ¡è¾¹
* ä»»æ„ä¸¤ä¸ªèŠ‚ç‚¹ä¹‹é—´è‡³å°‘å­˜åœ¨ä¸€æ¡è·¯å¾„

### é¢˜è§£

## å †ä¼˜åŒ– Dijkstra + åŠ¨æ€è§„åˆ’è§£æ³•

n ä¸ºç‚¹çš„æ•°é‡ï¼Œm ä¸ºè¾¹çš„æ•°é‡ã€‚

ä¸ºäº†æ–¹ä¾¿ç†è§£ï¼Œæˆ‘ä»¬å°†ç¬¬ n ä¸ªç‚¹ç§°ä¸ºã€Œèµ·ç‚¹ã€ï¼Œç¬¬ 1 ä¸ªç‚¹ç§°ä¸ºã€Œç»“å°¾ã€ã€‚

æŒ‰ç…§é¢˜æ„ï¼Œæˆ‘ä»¬éœ€è¦å…ˆæ±‚æ¯ä¸ªç‚¹åˆ°ç»“å°¾çš„ã€Œæœ€çŸ­è·¯ã€ï¼Œæ±‚æœ€çŸ­è·¯çš„ç®—æ³•æœ‰å¾ˆå¤šï¼Œé€šå¸¸æ ¹æ®ã€Œæœ‰æ— è´Ÿæƒè¾¹ã€& ã€Œç¨ å¯†å›¾è¿˜æ˜¯ç¨€ç–å›¾ã€è¿›è¡Œé€‰æ‹©ã€‚

è¯¥é¢˜åªæœ‰æ­£æƒå˜ï¼Œè€Œä¸”â€è¾¹â€œå’Œâ€ç‚¹â€œçš„æ•°é‡åœ¨ä¸€ä¸ªæ•°é‡çº§ä¸Šï¼Œå±äºç¨€ç–å›¾ã€‚

å› æ­¤æˆ‘ä»¬å¯ä»¥é‡‡ç”¨ã€Œæœ€çŸ­è·¯ã€ç®—æ³•ï¼šå †ä¼˜åŒ–çš„ Dijkstraï¼Œå¤æ‚åº¦ä¸º O*(*m*log*n)ã€‚

PS. é€šå¸¸ä¼šä¼˜å…ˆé€‰æ‹© SPFAï¼ŒSPFA é€šå¸¸æƒ…å†µä¸‹å¤æ‚åº¦ä¸º O(m)O(m)ï¼Œä½†æœ€åæƒ…å†µä¸‹å¤æ‚åº¦ä¸º O(nâˆ—m)ã€‚ä»æ•°æ®ä¸Šæ¥è¯´ SPFA ä¹Ÿä¼šè¶…ï¼Œè€Œä¸”æœ¬é¢˜è¿˜ç»“åˆäº† DPï¼Œå› æ­¤å¯èƒ½ä¼šå¡æ‰å›¾è®ºéƒ¨åˆ†çš„ SPFAã€‚å‡ºäºè¿™äº›è€ƒè™‘ï¼Œæˆ‘ç›´æ¥ä½¿ç”¨å †ä¼˜åŒ– Dijkstraã€‚

å½“æˆ‘ä»¬æ±‚å¾—äº†æ¯ä¸ªç‚¹åˆ°ç»“å°¾çš„ã€Œæœ€çŸ­è·¯ã€ä¹‹åï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬éœ€è¦æ±‚å¾—ä»ã€Œèµ·ç‚¹ã€åˆ°ã€Œç»“å°¾ã€çš„**å—é™è·¯å¾„æ•°é‡**ã€‚

è¿™æ˜¾ç„¶å¯ä»¥ç”¨ DP æ¥åšã€‚

æˆ‘ä»¬å®šä¹‰ dp(i) ä¸ºä»ç¬¬ i ä¸ªç‚¹åˆ°ç»“å°¾çš„å—é™è·¯å¾„æ•°é‡ï¼Œdp(1) å°±æ˜¯æˆ‘ä»¬çš„ç­”æ¡ˆï¼Œè€Œ dp(n) = 1 æ˜¯ä¸€ä¸ªæ˜¾è€Œæ˜“è§çš„èµ·å§‹æ¡ä»¶ã€‚

å› ä¸ºé¢˜ç›®çš„å—é™è·¯å¾„æ•°çš„å®šä¹‰ï¼Œæˆ‘ä»¬éœ€è¦æ‰¾çš„è·¯å¾„æ‰€åŒ…å«çš„ç‚¹ï¼Œå¿…é¡»æ˜¯å…¶è·ç¦»ç»“å°¾çš„æœ€çŸ­è·¯è¶Šæ¥è¶Šè¿‘çš„ã€‚

ä¸¾ä¸ªğŸŒ°ï¼Œå¯¹äºç¤ºä¾‹ 1ï¼Œå…¶ä¸­ä¸€æ¡ç¬¦åˆè¦æ±‚çš„è·¯å¾„ä¸º 1 --> 2 --> 3 --> 5ã€‚

è¿™æ¡è·¯å¾„çš„æœç´¢è¿‡ç¨‹å¯ä»¥çœ‹åšï¼Œä»ç»“å°¾ï¼ˆç¬¬ 5 ä¸ªç‚¹ï¼‰å‡ºå‘ï¼Œé€†ç€èµ°ï¼Œæ¯æ¬¡é€‰æ‹©ä¸€ä¸ªç‚¹ï¼ˆä¾‹å¦‚ aï¼‰ä¹‹åï¼Œå†é€‰æ‹©ä¸‹ä¸€ä¸ªç‚¹ï¼ˆä¾‹å¦‚ bï¼‰æ—¶å°±å¿…é¡»æ»¡è¶³æœ€çŸ­è·¯è·ç¦»æ¯”ä¸Šä¸€ä¸ªç‚¹ï¼ˆç‚¹ aï¼‰è¦è¿œï¼Œå¦‚æœæœ€ç»ˆèƒ½é€‰åˆ°èµ·ç‚¹ï¼ˆç¬¬ä¸€ä¸ªç‚¹ï¼‰ï¼Œè¯´æ˜ç»Ÿè®¡å‡ºä¸€æ¡æœ‰æ•ˆè·¯å¾„ã€‚

æˆ‘ä»¬çš„æœç´¢æ–¹å¼å†³å®šäº†éœ€è¦å…ˆæŒ‰ç…§æœ€çŸ­è·¯è·ç¦»è¿›è¡Œä»å°åˆ°å¤§æ’åºã€‚

**ä¸å¤±ä¸€èˆ¬æ€§ï¼Œå½“æˆ‘ä»¬è¦æ±‚ dp(i) çš„æ—¶å€™ï¼Œå…¶å®æ‰¾çš„æ˜¯ i ç‚¹å¯ä»¥åˆ°è¾¾çš„ç‚¹ jï¼Œå¹¶ä¸” j ç‚¹åˆ°ç»“å°¾çš„æœ€çŸ­è·¯è¦ä¸¥æ ¼å°äº i ç‚¹åˆ°ç»“å°¾çš„æœ€çŸ­è·¯ã€‚**

ç¬¦åˆæ¡ä»¶çš„ç‚¹ j æœ‰å¾ˆå¤šä¸ªï¼Œå°†æ‰€æœ‰çš„ dp(j) ç´¯åŠ å³æ˜¯ dp(i)ã€‚

```java
class Solution {
    public int countRestrictedPaths(int n, int[][] edges) {
        // è¿™é‡Œå–å€¼ ä¸èƒ½å» Integer.MAXVALUEå’Œ0x3f3f3f3f
        int INF = 0x7fffffff;
        int MOD = 1000000000 + 7;

        Map<Integer, List<int[]>> graph = new HashMap();
        for (int[] edge : edges) {
            // æ— å‘å›¾
            graph.computeIfAbsent(edge[0], t -> new ArrayList<>()).add(new int[]{edge[1], edge[2]});
            graph.computeIfAbsent(edge[1], t -> new ArrayList<>()).add(new int[]{edge[0], edge[2]});
        }

        // å †ä¼˜åŒ– Dijkstraï¼šæ±‚ æ¯ä¸ªç‚¹ åˆ° ç¬¬nä¸ªç‚¹ çš„æœ€çŸ­è·¯
        // èŠ‚ç‚¹ä¸‹æ ‡ä»1å¼€å§‹
        int[] distances = new int[n + 1];
        boolean[] visited = new boolean[n + 1];
        Arrays.fill(distances, INF);

        distances[n] = 0;
        PriorityQueue<int[]> queue = new PriorityQueue<int[]>((a, b) -> a[1] - b[1]);
        queue.add(new int[]{n, 0});

        while (!queue.isEmpty()) {
            int[] poll = queue.poll();
            int cur = poll[0];
            int weight = poll[1];

            if (visited[cur]) {
                continue;
            }
            visited[cur] = true;
            for (int[] neighbor : graph.getOrDefault(cur, new ArrayList<>())) {
                int next = neighbor[0];
                int nextWeight = neighbor[1];
                distances[next] = Math.min(distances[next], distances[cur] + nextWeight);
                queue.add(new int[]{next, distances[next]});
            }
        }

        // åŠ¨æ€è§„åˆ’è¿‡ç¨‹
        // èŠ‚ç‚¹ç¼–å·/æœ€çŸ­è·ç¦»
        int[][] arr = new int[n][2];
        for (int i = 0; i < n; i++) {
            arr[i] = new int[]{i + 1, distances[i + 1]};
        }

        Arrays.sort(arr, (a, b) -> a[1] - b[1]);

        int[] dp = new int[n + 1];
        dp[n] = 1;
        for (int i = 0; i < n; i++) {
            int curIndex = arr[i][0];
            int curValue = arr[i][1];
            for (int[] neighbor : graph.getOrDefault(curIndex, new ArrayList<>())) {
                int nextIndex = neighbor[0];
                if (curValue > distances[nextIndex]) {
                    dp[curIndex] += dp[nextIndex];
                    dp[curIndex] %= MOD;
                }
            }
        }

        return dp[1];
    }
}
```

