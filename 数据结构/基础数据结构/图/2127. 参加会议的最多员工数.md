#### 2127. 参加会议的最多员工数

一个公司准备组织一场会议，邀请名单上有 `n` 位员工。公司准备了一张 **圆形** 的桌子，可以坐下 **任意数目** 的员工。

员工编号为 0 到 n - 1 。每位员工都有一位 喜欢 的员工，每位员工 当且仅当 他被安排在喜欢员工的旁边，他才会参加会议。每位员工喜欢的员工 不会 是他自己。

给你一个下标从 **0** 开始的整数数组 `favorite` ，其中 `favorite[i]` 表示第 `i` 位员工喜欢的员工。请你返回参加会议的 **最多员工数目** 。

**示例 1：**

![img](http://gitlab.wsh-study.com/xp-study/LeeteCode/-/blob/master/数据结构/基础数据结构/图/images/参加会议的最多员工数/1.jpg)

```shell
输入：favorite = [2,2,1,2]
输出：3
解释：
上图展示了公司邀请员工 0，1 和 2 参加会议以及他们在圆桌上的座位。
没办法邀请所有员工参与会议，因为员工 2 没办法同时坐在 0，1 和 3 员工的旁边。
注意，公司也可以邀请员工 1，2 和 3 参加会议。
所以最多参加会议的员工数目为 3 。
```

**示例 2：**

```shell
输入：favorite = [1,2,0]
输出：3
解释：
每个员工都至少是另一个员工喜欢的员工。所以公司邀请他们所有人参加会议的前提是所有人都参加了会议。
座位安排同图 1 所示：
- 员工 0 坐在员工 2 和 1 之间。
- 员工 1 坐在员工 0 和 2 之间。
- 员工 2 坐在员工 1 和 0 之间。
参与会议的最多员工数目为 3 。
```

**示例 3：**

![img](http://gitlab.wsh-study.com/xp-study/LeeteCode/-/blob/master/数据结构/基础数据结构/图/images/参加会议的最多员工数/2.jpg)

```shell
输入：favorite = [3,0,1,4,1]
输出：4
解释：
上图展示了公司可以邀请员工 0，1，3 和 4 参加会议以及他们在圆桌上的座位。
员工 2 无法参加，因为他喜欢的员工 0 旁边的座位已经被占领了。
所以公司只能不邀请员工 2 。
参加会议的最多员工数目为 4 。
```

**提示：**

- `n == favorite.length`
- `2 <= n <= 105`
- `0 <= favorite[i] <= n - 1`
- `favorite[i] != i`

### 题解

本文将介绍处理基环树问题的一些通用技巧。

从 i 向 favorite[i] 连边，我们可以得到一张有向图。由于每个大小为 k 的连通块都有 k 个点和 k 条边，所以每个连通块必定有且仅有一个环，且由于每个点的出度均为 1，这样的有向图又叫做内向基环树 (pseudotree)，由基环树组成的森林叫基环树森林 (pseudoforest)。

每一个内向基环树（连通块）都由一个基环和其余指向基环的树枝组成。例如示例 3 可以得到如下内向基环树，其基环由节点 0、1、3 和 4 组成，节点 2 为其树枝：

![1.png](http://gitlab.wsh-study.com/xp-study/LeeteCode/-/blob/master/数据结构/基础数据结构/图/images/参加会议的最多员工数/3.jpg)

特别地，我们得到的基环可能只包含两个节点。例如示例 1 可以得到如下内向基环树，其基环只包含节点 1 和 2，而节点 0 和 3 组成其树枝：

![2.png](http://gitlab.wsh-study.com/xp-study/LeeteCode/-/blob/master/数据结构/基础数据结构/图/images/参加会议的最多员工数/4.jpg)

对于本题来说，这两类基环树在组成圆桌时会有明显区别，下文会说明这一点。

先来看看基环大小大于 2 的情况，显然基环上的节点组成了一个环，因而可以组成一个圆桌；而树枝上的点，若插入圆桌上 v→w 这两人中间，会导致节点 v 无法和其喜欢的员工坐在一起，因此树枝上的点是无法插入圆桌的；此外，树枝上的点也不能单独组成圆桌，因为这样会存在一个出度为 0 的节点，其无法和其喜欢的员工坐在一起。对于其余内向基环树（连通块）上的节点，和树枝同理，也无法插入该基环组成的圆桌。

因此，对于基环大小大于 2 的情况，圆桌的最大员工数目即为最大的基环大小，记作 maxRingSize。

下面来分析基环大小等于 2 的情况。

以如下基环树为例，0 和 1 组成基环，其余节点组成树枝：

![3.png](http://gitlab.wsh-study.com/xp-study/LeeteCode/-/blob/master/数据结构/基础数据结构/图/images/参加会议的最多员工数/5.jpg)

我们可以先让 0 和 1 坐在圆桌旁（假设 0 坐在 1 左侧），那么 0 这一侧的树枝只能坐在 0 的左侧，而 1 这一侧的树枝只能坐在 1 的右侧。

2 可以紧靠着坐在 0 的左侧，而 3 和 4 只能选一个坐在 2 的左侧（如果 4 紧靠着坐在 2 的左侧，那么 3 是无法紧靠着坐在 4 的左侧的，反之亦然）。

这意味着从 0 出发倒着找树枝上的点（即沿着反图上的边），每个点只能在其反图上选择其中一个子节点，因此 0 这一侧的节点必须组成一条链，那么我们可以找最长的那条链，即上图加粗的节点。

对于 1 这一侧也同理。将这两条最长链拼起来即为该基环树能组成的圆桌的最大员工数。

对于多个基环大小等于 2 的基环树，每个基环树所对应的链，都可以拼在其余链的末尾，因此我们可以将这些链全部拼成一个圆桌，其大小记作sumChainSize。

答案即为max(maxRingSize,sumChainSize)。



下面介绍基环树问题的通用写法。

我们可以通过一次拓扑排序「剪掉」所有树枝，因为拓扑排序后，树枝节点的入度均为 0，基环节点的入度均为 1。这样就可以将基环和树枝分开，从而简化后续处理流程：

* 如果要遍历基环，可以从拓扑排序后入度为 1 的节点出发，在图上搜索；
* 如果要遍历树枝，可以以基环与树枝的连接处为起点，顺着反图来搜索树枝（搜索入度为 0 的节点），从而将问题转化成一个树形问题。

对于本题，我们可以遍历所有基环，并按基环大小分类计算：

- 对于大小大于 2 的基环，我们取基环大小的最大值；
- 对于大小等于 2 的基环，我们可以从基环上的点出发，在反图上找到最大的树枝节点深度。

时间复杂度和空间复杂度均为 O(n)。

```java
class Solution {
    public int maximumInvitations(int[] favorite) {
        Map<Integer, List<Integer>> graph = new HashMap();
        int[] inDegree = new int[favorite.length];
        for (int i = 0; i < favorite.length; i++) {
            graph.computeIfAbsent(favorite[i], t -> new ArrayList<>()).add(i);
            inDegree[favorite[i]]++;
        }

        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < favorite.length; i++) {
            if (inDegree[i] == 0) {
                queue.add(i);
            }
        }

        while (!queue.isEmpty()) {
            int cur = queue.poll();
            int next = favorite[cur];
            inDegree[next]--;
            if (inDegree[next] == 0) {
                queue.add(next);
            }
        }

        // 根据处理后的入度信息来查询基环
        List<List<Integer>> baseCircles = findBaseCircle(favorite, inDegree);

        int max = Integer.MIN_VALUE;
        int sumLength = 0;
        for (List<Integer> baseCircle : baseCircles) {
            if (baseCircle.size() > 2) {
                max = Math.max(max, baseCircle.size());
            } else {
                sumLength += getLinkedLength(baseCircle.get(0), graph, inDegree) + getLinkedLength(baseCircle.get(1), graph, inDegree);
                max = Math.max(max, sumLength);
            }
        }

        return max;
    }

    public List<List<Integer>> findBaseCircle(int[] favorite, int[] inDegree) {
        List<List<Integer>> baseCircles = new ArrayList<>();
        boolean[] visited = new boolean[favorite.length];

        // 入度为0代表不在环上，可以标志已经访问
        for (int i = 0; i < favorite.length; i++) {
            if (inDegree[i] == 0) {
                visited[i] = true;
            }
        }

        for (int i = 0; i < favorite.length; i++) {
            if (visited[i]) {
                continue;
            }

            int next = i;
            List<Integer> baseCircle = new ArrayList<>();
            while (!visited[next]) {
                baseCircle.add(next);
                visited[next] = true;
                next = favorite[next];
            }
            baseCircles.add(baseCircle);
        }
        return baseCircles;
    }

    public int getLinkedLength(int cur, Map<Integer, List<Integer>> graph, int[] inDegree) {
        // 入度大于0，说明在环上，基环长度为2的时候不能走这些在环上的点
        boolean[] visited = new boolean[inDegree.length];
        for (int i = 0; i < inDegree.length; i++) {
            if (inDegree[i] > 0) {
                visited[i] = true;
            }
        }
        return dfs(cur, graph, visited);
    }

    public int dfs(int cur, Map<Integer, List<Integer>> graph, boolean[] visited) {
        List<Integer> nextList = graph.getOrDefault(cur, new ArrayList<>());
        int max = 0;
        for (int next : nextList) {
            if (!visited[next]) {
                max = Math.max(max, dfs(next, graph, visited));
            }
        }
        return max + 1;
    }
}
```

