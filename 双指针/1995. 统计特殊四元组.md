#### 1995. 统计特殊四元组

给你一个 **下标从 0 开始** 的整数数组 `nums` ，返回满足下述条件的 **不同** 四元组 `(a, b, c, d)` 的 **数目** ：

- `nums[a] + nums[b] + nums[c] == nums[d]` ，且
- `a < b < c < d`

**示例 1：**

```shell
输入：nums = [1,2,3,6]
输出：1
解释：满足要求的唯一一个四元组是 (0, 1, 2, 3) 因为 1 + 2 + 3 == 6 。
```

**示例 2：**

```shell
输入：nums = [3,3,6,4,5]
输出：0
解释：[3,3,6,4,5] 中不存在满足要求的四元组。
```

**示例 3：**

```shell
输入：nums = [1,1,1,3,5]
输出：4
解释：满足要求的 4 个四元组如下：
- (0, 1, 2, 3): 1 + 1 + 1 == 3
- (0, 1, 3, 4): 1 + 1 + 3 == 5
- (0, 2, 3, 4): 1 + 1 + 3 == 5
- (1, 2, 3, 4): 1 + 1 + 3 == 5
```

**提示：**

- `4 <= nums.length <= 50`
- `1 <= nums[i] <= 100`

### 题解

**三数之和(双指针)**

```java
class Solution {
    public int countQuadruplets(int[] nums) {
        int n = nums.length;
        if (n < 4) {
            return 0;
        }

        int ans = 0;
        for (int i = 3; i < n; i++) {
            int begin = 0;
            int end = i - 1;
            int target = nums[i];
            ans += threeSumMulti(nums, begin, end, target);
        }
        return ans;
    }


    public int threeSumMulti(int[] nums, int begin, int end, int target) {
        int MOD = 1000000007;
        long ans = 0;

        int[] A = Arrays.copyOfRange(nums, begin, end+1);
        Arrays.sort(A);

        for (int i = begin; i <= end; i++) {
            int T = target - A[i];
            int j = i + 1;
            int k = A.length - 1;
            while (j < k) {
                if (A[j] + A[k] < T) {
                    j++;
                } else if (A[j] + A[k] > T) {
                    k--;
                } else {
                    if (A[j] != A[k]) {
                        int left = 1;
                        int right = 1;
                        while (j + 1 < k && A[j] == A[j + 1]) {
                            left++;
                            j++;
                        }

                        while (k - 1 > j && A[k] == A[k - 1]) {
                            right++;
                            k--;
                        }

                        ans += left * right;
                        ans %= MOD;
                        j++;
                        k--;
                    } else {
                        ans += (k - j + 1) * (k - j) / 2;
                        ans %= MOD;
                        break;
                    }
                }
            }
        }
        return (int) ans;
    }
}
```

