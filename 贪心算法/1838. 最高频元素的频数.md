#### 1838. 最高频元素的频数

元素的 **频数** 是该元素在一个数组中出现的次数。

给你一个整数数组 `nums` 和一个整数 `k` 。在一步操作中，你可以选择 `nums` 的一个下标，并将该下标对应元素的值增加 `1` 。

执行最多 `k` 次操作后，返回数组中最高频元素的 **最大可能频数** *。*

**示例 1：**

```shell
输入：nums = [1,2,4], k = 5
输出：3
解释：对第一个元素执行 3 次递增操作，对第二个元素执 2 次递增操作，此时 nums = [4,4,4] 。
4 是数组中最高频元素，频数是 3 。
```

**示例 2：**

```shell
输入：nums = [1,4,8,13], k = 5
输出：2
解释：存在多种最优解决方案：
- 对第一个元素执行 3 次递增操作，此时 nums = [4,4,8,13] 。4 是数组中最高频元素，频数是 2 。
- 对第二个元素执行 4 次递增操作，此时 nums = [1,8,8,13] 。8 是数组中最高频元素，频数是 2 。
- 对第三个元素执行 5 次递增操作，此时 nums = [1,4,13,13] 。13 是数组中最高频元素，频数是 2 。
```

**示例 3：**

```shell
输入：nums = [3,9,6], k = 2
输出：1
```

**提示：**

- `1 <= nums.length <= 105`
- `1 <= nums[i] <= 105`
- `1 <= k <= 105`

### 题解

### 解题思路

首先很容易想到，先对数组进行排序。

接下来，我们只需要找到某一段区间内，每个值与该区间内最后一个值相差的总和，不超过目标k的最大值。

### 举个例子：

数组：1，2，4，6

k：5

* 第一次在【1，2】范围内，如果要让1变成2，那么就加1即可。
* 第二次扩大到【1，2，4】范围内，如果要让1变成4，2变成4，那么一共需要增加5次。
* 第三次扩大到【1，2，4，6】范围内，依次类推，每个值变为6，一共需要11次。（此时11次已经超过了5次的操作上限，那么就滑动窗口的区间）

接下来，我们只需要依次判断窗口内满足条件的最大值即可。

### 简单的图例

第一次区间内，需要加1（满足）

![image.png](http://gitlab.wsh-study.com/xp-study/LeeteCode/blob/master/贪心算法/images/最高频元素的频数/1.jpg)

第二次区间内，需要加5（满足）

![image.png](http://gitlab.wsh-study.com/xp-study/LeeteCode/blob/master/贪心算法/images/最高频元素的频数/2.jpg)

第三次区间内，需要加11（不满足）

![image.png](http://gitlab.wsh-study.com/xp-study/LeeteCode/blob/master/贪心算法/images/最高频元素的频数/3.jpg)

由于超过了目标值5，所以窗口左侧，向右移动一位。

![image.png](http://gitlab.wsh-study.com/xp-study/LeeteCode/blob/master/贪心算法/images/最高频元素的频数/4.jpg)

依此类推。。。

### 代码

```java
//leetcode submit region begin(Prohibit modification and deletion)
class Solution {
    public int maxFrequency(int[] nums, int k) {
        int ans = 1;
        int j = 0;
        long windows = 0;
        Arrays.sort(nums);

        for (int i = 1; i < nums.length; i++) {
            // 计算区间内每个值，与区间内最后一个值相差的总和
            windows += (nums[i] - nums[i - 1]) * (i - j);

            // 如果超过目标值
            while (windows > k) {
                // 那么就减去区间内最左侧的值与最后一个值的差距。
                // 然后再让区间左侧向右移动一位，相等于整个区间缩小了一位距离，在缩小的区间内再判断是否满足要求
                windows -= nums[i] - nums[j];
                j++;
            }
            ans = Math.max(ans, i - j + 1);
        }
        return ans;
    }
}
//leetcode submit region end(Prohibit modification and deletion)

```

