#### 1798. 你能构造出连续值的最大数目

给你一个长度为 n 的整数数组 coins ，它代表你拥有的 n 个硬币。第 i 个硬币的值为 coins[i] 。如果你从这些硬币中选出一部分硬币，它们的和为 x ，那么称，你可以 构造 出 x 。

请返回从 `0` 开始（**包括** `0` ），你最多能 **构造** 出多少个连续整数。

你可能有多个相同值的硬币。

**示例 1：**

```shell
输入：coins = [1,3]
输出：2
解释：你可以得到以下这些值：
- 0：什么都不取 []
- 1：取 [1]
从 0 开始，你可以构造出 2 个连续整数。
```

**示例 2：**

```shell
输入：coins = [1,1,1,4]
输出：8
解释：你可以得到以下这些值：
- 0：什么都不取 []
- 1：取 [1]
- 2：取 [1,1]
- 3：取 [1,1,1]
- 4：取 [4]
- 5：取 [4,1]
- 6：取 [4,1,1]
- 7：取 [4,1,1,1]
从 0 开始，你可以构造出 8 个连续整数。
```

**示例 3：**

```shell
输入：nums = [1,4,10,3,1]
输出：20
```

**提示：**

- `coins.length == n`
- `1 <= n <= 4 * 104`
- `1 <= coins[i] <= 4 * 104`

### 题解

#### 方法一：数学

**提示 1**

假设数组中若干个元素可以构造出  [0,x] 范围内的所有整数。如果此时我们再多选择一个元素 y，那么这些元素可以构造出[0,x] 以及 [y,y+x] 范围内的所有整数。

**提示 2**

如果我们希望这个多选择的元素 y使得答案变得更大，那么区间 [0, x]和 [y, y+x] 需要满足什么要求？

**思路与算法**

由于我们需要从 0 开始构造出尽可能多的连续整数，而不在区间 [0,x] 中的最小整数是 x+1，因此如果 x+1 在区间 [y,y+x] 中，那么元素 y就会使得构造出的连续整数的范围从[0,x] 增加到 [0,y+x]；否则，元素 y 不会对答案产生任何影响。

由于数组中的元素都是正整数，那么 x+1≤y+x 恒成立，我们只需要求y≤x+1 即可保证 x+1 在区间 [y,y+x] 中。

这样一来，我们只需要找出数组中还未被选的元素中最小的那个作为 y 即可。如果y≤x+1，那么就可以更新答案区间，否则剩下更大的元素也不会对答案产生任何影响。

初始时我们没有选择任何元素，对应的区间为[0,0]。随后我们将数组中的元素升序排序，然后依次判断是否能更新答案区间即可。

**代码**

```java
//leetcode submit region begin(Prohibit modification and deletion)
class Solution {
    public int getMaximumConsecutive(int[] coins) {
        Arrays.sort(coins);
        int x = 0;
        for (int y : coins) {
            if (x + 1 >= y) {
                x += y;
            } else {
                break;
            }
        }
        return x + 1;
    }
}
//leetcode submit region end(Prohibit modification and deletion)

```

