#### 1608. 特殊数组的特征值

给你一个非负整数数组 nums 。如果存在一个数 x ，使得 nums 中恰好有 x 个元素 大于或者等于 x ，那么就称 nums 是一个 特殊数组 ，而 x 是该数组的 特征值 。

注意： `x` **不必** 是 `nums` 的中的元素。

如果数组 `nums` 是一个 **特殊数组** ，请返回它的特征值 `x` 。否则，返回 `-1` 。可以证明的是，如果 `nums` 是特殊数组，那么其特征值 `x` 是 **唯一的** 。

**示例 1：**

```shell
输入：nums = [3,5]
输出：2
解释：有 2 个元素（3 和 5）大于或等于 2 。
```

**示例 2：**

```shell
输入：nums = [0,0]
输出：-1
解释：没有满足题目要求的特殊数组，故而也不存在特征值 x 。
如果 x = 0，应该有 0 个元素 >= x，但实际有 2 个。
如果 x = 1，应该有 1 个元素 >= x，但实际有 0 个。
如果 x = 2，应该有 2 个元素 >= x，但实际有 0 个。
x 不能取更大的值，因为 nums 中只有两个元素。
```

**示例 3：**

```shell
输入：nums = [0,4,3,0,4]
输出：3
解释：有 3 个元素大于或等于 3 。
```

**示例 4：**

```shell
输入：nums = [3,6,7,7,0]
输出：-1
```

**提示：**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 1000`

### 题解

### 解题思路

如果使用排序的话，时间复杂度会到达O(nlogn)，所以如果能不用，就尽力不用。
如果使用二分的话，每一次判断二分取到的值跟数组元素个数对比时，都要做一次遍历，时间复杂度也会到O(nlogn)。

理解题意后，我们发现，我们只关心每个数字个数，并不关心他们的位置，所以我们不排序，只统计数字。
统计数目的话，如果在有限范围内（本题的元素最大值是1000，可以使用），使用数组计数是最快的，比哈希表快。

我们不必创建一个长度是1001的数组，只需要创建一个长度是数组元素最大值加1的长度的数组counts，用来计数。

接下来我们分析答案的范围，如果答案存在，那么肯定是在 1 到 数组元素最大值之间。

再然后我们要思考是顺序遍历还是倒序遍历：
因为这道题是元素的个数要大于等于x，所以我们使用倒序遍历的方法，让x值最开始等于最大值，跟最大值的数目进行对比，然后递减，让元素个数累加，依次对比，能最快找到答案。

其实如果顺序遍历也可以，但是要提前统计出数组中所有元素的个数总和，然后随着x值的递增，在依次减去元素个数，再进行对比。

### 复杂度分析

时间复杂度：O(n)，由 O(min(nums.length, maxVal)) 推导出。
空间复杂度：O(n)，创建了一个用于计数的数组。

```java
class Solution {
    public int specialArray(int[] nums) {
        int maxVal = Integer.MIN_VALUE;
        for (int num : nums) {
            if (num > maxVal) {
                maxVal = num;
            }
        }

        int[] counts = new int[maxVal + 1];
        for (int num : nums) {
            counts[num]++;
        }

        int sum = 0;

        for (int i = maxVal; i >= 0; i--) {
            sum += counts[i];
            if (sum == i) {
                return i;
            }
        }
        return -1;
    }
}
```

