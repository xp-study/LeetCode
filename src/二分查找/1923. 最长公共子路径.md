#### 1923. 最长公共子路径

一个国家由 `n` 个编号为 `0` 到 `n - 1` 的城市组成。在这个国家里，**每两个** 城市之间都有一条道路连接。

总共有 m 个编号为 0 到 m - 1 的朋友想在这个国家旅游。他们每一个人的路径都会包含一些城市。每条路径都由一个整数数组表示，每个整数数组表示一个朋友按顺序访问过的城市序列。同一个城市在一条路径中可能 重复 出现，但同一个城市在一条路径中不会连续出现。

给你一个整数 n 和二维数组 paths ，其中 paths[i] 是一个整数数组，表示第 i 个朋友走过的路径，请你返回 每一个 朋友都走过的 最长公共子路径 的长度，如果不存在公共子路径，请你返回 0 。

一个 **子路径** 指的是一条路径中连续的城市序列。

**示例 1：**

```shell
输入：n = 5, paths = [[0,1,2,3,4],
                     [2,3,4],
                     [4,0,1,2,3]]
输出：2
解释：最长公共子路径为 [2,3] 。
```

**示例 2：**

```shell
输入：n = 3, paths = [[0],[1],[2]]
输出：0
解释：三条路径没有公共子路径。
```

**示例 3：**

```shell
输入：n = 5, paths = [[0,1,2,3,4],
                     [4,3,2,1,0]]
输出：1
解释：最长公共子路径为 [0]，[1]，[2]，[3] 和 [4] 。它们长度都为 1 。
```

**提示：**

* 1 <= n <= 105
* m == paths.length
* 2 <= m <= 105
* sum(paths[i].length) <= 105
* `0 <= paths[i][j] < n`
* paths[i] 中同一个城市不会连续重复出现。

### 题解

**旋转Hash+二分查找**

```java
class Solution {

    int maxn = (int) (1e5 + 50);
    int mod1 = (int) (1e9 + 7);
    int mod2 = (int) (1e9 + 9);
    int p = (int) (1e6 + 3);

    long[] pow1 = new long[maxn];
    long[] pow2 = new long[maxn];

    public int longestCommonSubpath(int n, int[][] paths) {
        pow1[0] = pow2[0] = 1;
        for (int i = 1; i < maxn; i++) {
            pow1[i] = pow1[i - 1] * p % mod1;
            pow2[i] = pow2[i - 1] * p % mod2;
        }

        int l = 1;
        int h = (int) 1e6;

        while (l + 1 < h) {
            int mid = l + ((h - l) >> 1);
            if (check(paths, mid)) {
                l = mid;
            } else {
                h = mid;
            }
        }

        if (check(paths, h)) {
            return h;
        }

        if (check(paths, l)) {
            return l;
        }

        return 0;
    }


    public boolean check(int[][] paths, int len) {

        int m = paths.length;
        Map<String, Integer> map = new HashMap<>();
        for (int[] path : paths) {
            if (path.length < len) {
                return false;
            }

            long h1 = 0;
            long h2 = 0;

            for (int i = 0; i < len; i++) {
                h1 = (h1 * p + path[i]) % mod1;
                h2 = (h2 * p + path[i]) % mod2;
            }

            Set<String> set = new HashSet<>();
            String h = h1 + "-" + h2;
            if (!set.contains(h)) {
                set.add(h);
                int count = map.getOrDefault(h, 0) + 1;
                if (count == m) {
                    return true;
                }
                map.put(h, count);
            }

            long mult1 = pow1[len - 1];
            long mult2 = pow2[len - 1];

            for (int i = len; i < path.length; i++) {
                h1 = ((h1 - path[i - len] * mult1 % mod1 + mod1) % mod1 * p + path[i]) % mod1;
                h2 = ((h2 - path[i - len] * mult2 % mod2 + mod2) % mod2 * p + path[i]) % mod2;
                h = h1 + "-" + h2;
                if (!set.contains(h)) {
                    set.add(h);
                    int count = map.getOrDefault(h, 0) + 1;
                    if (count == m) {
                        return true;
                    }
                    map.put(h, count);
                }
            }
        }
        return false;
    }
}
```

