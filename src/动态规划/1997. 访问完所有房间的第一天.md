#### 1997. 访问完所有房间的第一天

你需要访问 `n` 个房间，房间从 `0` 到 `n - 1` 编号。同时，每一天都有一个日期编号，从 `0` 开始，依天数递增。你每天都会访问一个房间。

最开始的第 0 天，你访问 0 号房间。给你一个长度为 n 且 下标从 0 开始 的数组 nextVisit 。在接下来的几天中，你访问房间的 次序 将根据下面的 规则 决定：

- 假设某一天，你访问 `i` 号房间。

* 如果算上本次访问，访问 i 号房间的次数为 奇数 ，那么 第二天 需要访问 nextVisit[i] 所指定的房间，其中 0 <= nextVisit[i] <= i 。

- 如果算上本次访问，访问 `i` 号房间的次数为 **偶数** ，那么 **第二天** 需要访问 `(i + 1) mod n` 号房间。

请返回你访问完所有房间的第一天的日期编号。题目数据保证总是存在这样的一天。由于答案可能很大，返回对 `109 + 7` 取余后的结果。

**示例 1：**

```shell
输入：nextVisit = [0,0]
输出：2
解释：
- 第 0 天，你访问房间 0 。访问 0 号房间的总次数为 1 ，次数为奇数。
  下一天你需要访问房间的编号是 nextVisit[0] = 0
- 第 1 天，你访问房间 0 。访问 0 号房间的总次数为 2 ，次数为偶数。
  下一天你需要访问房间的编号是 (0 + 1) mod 2 = 1
- 第 2 天，你访问房间 1 。这是你第一次完成访问所有房间的那天。
```

**示例 2：**

```shell
输入：nextVisit = [0,0,2]
输出：6
解释：
你每天访问房间的次序是 [0,0,1,0,0,1,2,...] 。
第 6 天是你访问完所有房间的第一天。
```

**示例 3：**

```shell
输入：nextVisit = [0,1,2,0]
输出：6
解释：
你每天访问房间的次序是 [0,0,1,1,2,2,3,...] 。
第 6 天是你访问完所有房间的第一天。
```

**提示：**

- `n == nextVisit.length`
- `2 <= n <= 105`
- `0 <= nextVisit[i] <= i`

### 题解

**动态规划**

```java
class Solution {
    //dp[i] 代表可以房间0到房间i的天数
    //到i房间之前必然先到i-1房间，即为dp[i-1]
    //现在考虑从i-1房间到i房间所可能经历的过程
    //1：若next[i-1] = i-1; 我们下一天还在原地，第二天可以到i
    //故所花时间2天 
    //dp[i] = 2 + dp[i-1]
    //2: 若不等，我们需要跳到 next[i-1] 房间，从next[i-1]房间最终再次
    //跳到i-1房间，使得房间访问次数奇偶变化 才能向右移到i房间
    //从i-1跳到next[i-1]需要1天，从next[i-1]跳回i-1需要dp[i-1]-dp[next[i-1]]天，最后从i-1跳到i需要最后1天.
    //故从i-1完整跳到i需要 2 + dp[i-1] - dp[next[i-1]];
    //dp[i] = dp[i-1]+2+dp[i-1]-dp[next[i-1]]
    //        = 2+2*dp[i-1] - dp[next[i-1]];
    //综合可以总结为dp[i] = 2 + 2*dp[i-1] - dp[next[i-1]];
    //因为数很大，所以取模
    public int firstDayBeenInAllRooms(int[] nextVisit) {
        int MOD = 1000000000 + 7;
        int n = nextVisit.length;
        long[] dp = new long[n];
        for (int i = 1; i < n; i++) {
            dp[i] = (dp[i - 1] + 2 + dp[i - 1] - dp[nextVisit[i - 1]] + MOD) % MOD;
        }
        return (int) (dp[n - 1] % MOD);
    }
}
```

