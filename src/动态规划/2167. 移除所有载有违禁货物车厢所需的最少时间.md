#### 2167. 移除所有载有违禁货物车厢所需的最少时间

给你一个下标从 0 开始的二进制字符串 s ，表示一个列车车厢序列。s[i] = '0' 表示第 i 节车厢 不 含违禁货物，而 s[i] = '1' 表示第 i 节车厢含违禁货物。

作为列车长，你需要清理掉所有载有违禁货物的车厢。你可以不限次数执行下述三种操作中的任意一个：

1. 从列车 左 端移除一节车厢（即移除 s[0]），用去 1 单位时间。
2. 从列车 右 端移除一节车厢（即移除 s[s.length - 1]），用去 1 单位时间。
3. 从列车车厢序列的 任意位置 移除一节车厢，用去 2 单位时间。

返回移除所有载有违禁货物车厢所需要的 **最少** 单位时间数。

注意，空的列车车厢序列视为没有车厢含违禁货物。

 **示例 1：**

```shell
输入：s = "1100101"
输出：5
解释：
一种从序列中移除所有载有违禁货物的车厢的方法是：
- 从左端移除一节车厢 2 次。所用时间是 2 * 1 = 2 。
- 从右端移除一节车厢 1 次。所用时间是 1 。
- 移除序列中间位置载有违禁货物的车厢。所用时间是 2 。
总时间是 2 + 1 + 2 = 5 。

一种替代方法是：
- 从左端移除一节车厢 2 次。所用时间是 2 * 1 = 2 。
- 从右端移除一节车厢 3 次。所用时间是 3 * 1 = 3 。
总时间也是 2 + 3 = 5 。

5 是移除所有载有违禁货物的车厢所需要的最少单位时间数。
没有其他方法能够用更少的时间移除这些车厢。
```

**示例 2：**

```shell
输入：s = "0010"
输出：2
解释：
一种从序列中移除所有载有违禁货物的车厢的方法是：
- 从左端移除一节车厢 3 次。所用时间是 3 * 1 = 3 。
总时间是 3.

另一种从序列中移除所有载有违禁货物的车厢的方法是：
- 移除序列中间位置载有违禁货物的车厢。所用时间是 2 。
总时间是 2.

另一种从序列中移除所有载有违禁货物的车厢的方法是：
- 从右端移除一节车厢 2 次。所用时间是 2 * 1 = 2 。
总时间是 2.

2 是移除所有载有违禁货物的车厢所需要的最少单位时间数。
没有其他方法能够用更少的时间移除这些车厢。
```

**提示：**

- `1 <= s.length <= 2 * 105`
- `s[i]` 为 `'0'` 或 `'1'`

### 题解

**两次动态规划**

```java
class Solution {
    public int minimumTime(String s) {
        int n = s.length();

        if (n == 1) {
            if (s.charAt(0) == '0') {
                return 0;
            }
            return 1;
        }

        // 从左往右移除违禁物品车厢
        // 定义 dpLeft[i]表示移除到当前位置的所有违禁物品的车厢所消耗的时间
        int[] dpLeft = new int[n];
        dpLeft[0] = s.charAt(0) == '0' ? 0 : 1;

        for (int i = 1; i < n; i++) {
            if (s.charAt(i) == '0') {
                dpLeft[i] = dpLeft[i - 1];
            } else {
                dpLeft[i] = Math.min(dpLeft[i - 1] + 2, i + 1);
            }
        }

        // 从右往左移除违禁物品车厢
        // 定义 dpRight[i]表示移除到当前位置的所有违禁物品的车厢所消耗的时间
        int[] dpRight = new int[n];
        dpRight[n - 1] = s.charAt(n - 1) == '0' ? 0 : 1;
        for (int i = n - 2; i >= 0; i--) {
            if (s.charAt(i) == '0') {
                dpRight[i] = dpRight[i + 1];
            } else {
                dpRight[i] = Math.min(dpRight[i + 1] + 2, n - i);
            }
        }

        int ans = Integer.MAX_VALUE;
        for (int i = 0; i < n - 1; i++) {
            ans = Math.min(ans, dpLeft[i] + dpRight[i + 1]);
        }

        ans = Math.min(ans, dpLeft[n - 1]);
        return ans;
    }
}
```

